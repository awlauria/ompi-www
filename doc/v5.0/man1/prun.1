.\" Automatically generated by Pandoc 2.14.2
.\"
.TH "prun" "1" "" "2021-08-23" "PRRTE"
.hy
.SH NAME
.PP
prun - Execute serial and parallel jobs with the PMIx Reference Runtime
(PRTE).
.SH SYNOPSIS
.PP
\f[C]prun\f[R] requires a running \f[C]prte\f[R] Distributed Virtual
Machine (DVM) to be running at the time of the call.
See prte(1) for more information.
.PP
Single Process Multiple Data (SPMD) Model:
.IP
.nf
\f[C]
prun [ options ] <program> [ <args> ]
\f[R]
.fi
.PP
Multiple Instruction Multiple Data (MIMD) Model:
.IP
.nf
\f[C]
prun [ global_options ] \[rs]
     [ local_options1 ] <program1> [ <args1> ] : \[rs]
     [ local_options2 ] <program2> [ <args2> ] : \[rs]
     ... : \[rs]
     [ local_optionsN ] <programN> [ <argsN> ]
\f[R]
.fi
.PP
Note that in both models, invoking \f[C]prun\f[R] via an absolute path
name is equivalent to specifying the \f[C]--prefix\f[R] option with a
\f[C]<dir>\f[R] value equivalent to the directory where \f[C]prun\f[R]
resides, minus its last subdirectory.
For example:
.IP
.nf
\f[C]
$ /usr/local/bin/prun ...
\f[R]
.fi
.PP
is equivalent to
.IP
.nf
\f[C]
$ prun --prefix /usr/local
\f[R]
.fi
.SH QUICK SUMMARY
.PP
If you are simply looking for how to run an application, you probably
want to use a command line of the following form:
.IP
.nf
\f[C]
$ prun [ -np X ] [ --hostfile <filename> ] <program>
\f[R]
.fi
.PP
This will run \f[C]X\f[R] copies of \f[C]<program>\f[R] in your current
run-time environment over the set of hosts specified by
\f[C]<filename>\f[R], scheduling (by default) in a round-robin fashion
by CPU slot.
If running under a supported resource manager a hostfile is usually not
required unless the caller wishes to further restrict the set of
resources used for that job.
.PP
Please note that PRTE automatically binds processes.
See prte-map(1) for defaults for the mapping, ranking, and binding of
processes.
.PP
If your application uses threads, then you probably want to ensure that
you are either not bound at all (by specifying
\f[C]--bind-to none\f[R]), or bound to multiple cores using an
appropriate binding level or specific number of processing elements per
application process.
.PP
Default ranking is by \f[C]slot\f[R] if number of processes <= 2,
otherwise default to ranking by \f[C]package\f[R] (formally known as
\[lq]socket\[rq]).
.PP
See prte-map(1) for more details on mapping, ranking, and binding
options.
.SH OPTIONS
.PP
This section includes many commonly used options.
There may be other options listed with \f[C]prun --help\f[R].
.PP
\f[C]prun\f[R] will send the name of the directory where it was invoked
on the local node to each of the remote nodes, and attempt to change to
that directory.
See the \[lq]Current Working Directory\[rq] section below for further
details.
.TP
\f[B]\f[CB]<program>\f[B]\f[R]
The program executable.
This is identified as the first non-recognized argument to
\f[C]prun\f[R].
.TP
\f[B]\f[CB]<args>\f[B]\f[R]
Pass these run-time arguments to every new process.
These must always be the last arguments to \f[C]prun\f[R] after the
\f[C]<program>\f[R].
If an app context file is used, \f[C]<args>\f[R] will be ignored.
.TP
\f[B]\f[CB]-h, --help\f[B]\f[R]
Display help for this command
.TP
\f[B]\f[CB]-q, --quiet\f[B]\f[R]
Suppress informative messages from \f[C]prun\f[R] during application
execution.
.TP
\f[B]\f[CB]-v, --verbose\f[B]\f[R]
Be verbose
.TP
\f[B]\f[CB]-V, --version\f[B]\f[R]
Print version number.
If no other arguments are given, this will also cause \f[C]prun\f[R] to
exit.
.SS Specifying Number of Processes
.PP
The following options specify the number of processes to launch.
Note that none of the options imply a particular binding policy - e.g.,
requesting N processes for each socket does not imply that the processes
will be bound to the package.
.PP
Additional options and details are presented in prte-map(1).
Below are a few of the commonly used options.
.TP
\f[B]\f[CB]-c, -n, --n, --np <#>\f[B]\f[R]
Run this many copies of the program on the given nodes.
This option indicates that the specified file is an executable program
and not an application context.
If no value is provided for the number of copies to execute (i.e.,
neither the \f[C]--np\f[R] nor its synonyms are provided on the command
line), \f[C]prun\f[R] will automatically execute a copy of the program
on each process slot (see below for description of a \[lq]process
slot\[rq]).
This feature, however, can only be used in the SPMD model and will
return an error (without beginning execution of the application)
otherwise.
.SS I/O Management
.PP
To manage standard I/O:
.TP
\f[B]\f[CB]--output-filename <filename>\f[B]\f[R]
Redirect the \f[C]stdout\f[R], \f[C]stderr\f[R], and \f[C]stddiag\f[R]
of all processes to a process-unique version of the specified filename
(\[lq]filename.id\[rq]).
Any directories in the filename will automatically be created.
Each output file will consist of \[lq]filename.id\[rq], where the
\f[C]id\f[R] will be the processes\[cq] rank, left-filled with
zero\[cq]s for correct ordering in listings.
Both \f[C]stdout\f[R] and \f[C]stderr\f[R] will be redirected to the
file.
A relative path value will be converted to an absolute path based on the
current working directory where \f[C]prun\f[R] is executed.
Note that this \f[I]will not\f[R] work in environments where the file
system on compute nodes differs from that where \f[C]prun\f[R] is
executed.
This option accepts one case-insensitive directive, specified after a
colon (\f[C]:\f[R]): \f[C]NOCOPY\f[R] indicates that the output is not
to be echoed to the terminal.
.TP
\f[B]\f[CB]--output-directory <path>\f[B]\f[R]
Redirect the \f[C]stdout\f[R], \f[C]stderr\f[R], and \f[C]stddiag\f[R]
of all processes to a process-unique location consisting of
\[lq]//rank.id/std[out,err,diag]\[rq], where the \f[C]id\f[R] will be
the processes\[cq] rank, left-filled with zero\[cq]s for correct
ordering in listings.
Any directories in the filename will automatically be created.
A relative path value will be converted to an absolute path based on the
current working directory where \f[C]prun\f[R] is executed.
Note that this \f[I]will not\f[R] work on environments where the file
system on compute nodes differs from that where \f[C]prun\f[R] is
executed.
This option also supports two case-insensitive directives, specified in
comma-delimited form after a colon (\f[C]:\f[R]): \f[C]NOJOBID\f[R]
(omits the jobid directory layer) and \f[C]NOCOPY\f[R] (do not copy the
output to the terminal).
.TP
\f[B]\f[CB]--stdin <rank>\f[B]\f[R]
The rank of the process that is to receive \f[C]stdin\f[R].
The default is to forward \f[C]stdin\f[R] to rank 0, but this option can
be used to forward \f[C]stdin\f[R] to any process.
It is also acceptable to specify \f[C]none\f[R], indicating that no
processes are to receive \f[C]stdin\f[R].
.TP
\f[B]\f[CB]--merge-stderr-to-stdout\f[B]\f[R]
Merge \f[C]stderr\f[R] to \f[C]stdout\f[R] for each process.
.TP
\f[B]\f[CB]--map-by :TAGOUTPUT\f[B]\f[R]
Tag each line of output to \f[C]stdout\f[R], \f[C]stderr\f[R], and
\f[C]stddiag\f[R] with \f[C][jobid, MCW_rank]<stdxxx>\f[R] indicating
the jobid and rank of the process that generated the output, and the
channel which generated it.
.TP
\f[B]\f[CB]--map-by :TIMESTAMPOUTPUT\f[B]\f[R]
Timestamp each line of output to \f[C]stdout\f[R], \f[C]stderr\f[R], and
\f[C]stddiag\f[R].
.TP
\f[B]\f[CB]--map-by :XMLOUTPUT\f[B]\f[R]
Provide all output to \f[C]stdout\f[R], \f[C]stderr\f[R], and
\f[C]stddiag\f[R] in an xml format.
.TP
\f[B]\f[CB]--xterm <ranks>\f[B]\f[R]
Display the output from the processes identified by their ranks in
separate \f[C]xterm\f[R] windows.
The ranks are specified as a comma-separated list of ranges, with a
\f[C]-1\f[R] indicating all.
A separate window will be created for each specified process.
\f[B]Note:\f[R] \f[C]xterm\f[R] will normally terminate the window upon
termination of the process running within it.
However, by adding a \[lq]!\[rq] to the end of the list of specified
ranks, the proper options will be provided to ensure that
\f[C]xterm\f[R] keeps the window open \f[I]after\f[R] the process
terminates, thus allowing you to see the process\[cq] output.
Each \f[C]xterm\f[R] window will subsequently need to be manually
closed.
\f[B]Note:\f[R] In some environments, \f[C]xterm\f[R] may require that
the executable be in the user\[cq]s path, or be specified in absolute or
relative terms.
Thus, it may be necessary to specify a local executable as
\[lq]./foo\[rq] instead of just \[lq]foo\[rq].
If \f[C]xterm\f[R] fails to find the executable, \f[C]prun\f[R] will
hang, but still respond correctly to a ctrl-c.\ If this happens, please
check that the executable is being specified correctly and try again.
.SS File and Environment Management
.PP
To manage files and runtime environment:
.TP
\f[B]\f[CB]--path <path>\f[B]\f[R]
\f[C]<path>\f[R] that will be used when attempting to locate the
requested executables.
This is used prior to using the local \f[C]PATH\f[R] setting.
.TP
\f[B]\f[CB]--prefix <dir>\f[B]\f[R]
Prefix directory that will be used to set the \f[C]PATH\f[R] and
\f[C]LD_LIBRARY_PATH\f[R] on the remote node before invoking the target
process.
See the \[lq]Remote Execution\[rq] section, below.
.TP
\f[B]\f[CB]--noprefix\f[B]\f[R]
Disable the automatic \f[C]--prefix\f[R] behavior
.TP
\f[B]\f[CB]-s | --preload-binary\f[B]\f[R]
Copy the specified executable(s) to remote machines prior to starting
remote processes.
The executables will be copied to the session directory and will be
deleted upon completion of the job.
.TP
\f[B]\f[CB]--preload-files <files>\f[B]\f[R]
Preload the comma separated list of files to the current working
directory of the remote machines where processes will be launched prior
to starting those processes.
.TP
\f[B]\f[CB]--set-cwd-to-session-dir\f[B]\f[R]
Set the working directory of the started processes to their session
directory.
.TP
\f[B]\f[CB]--wdir <dir>\f[B]\f[R]
Change to the directory \f[C]<dir>\f[R] before the user\[cq]s program
executes.
See the \[lq]Current Working Directory\[rq] section for notes on
relative paths.
\f[B]Note:\f[R] If the \f[C]--wdir\f[R] option appears both on the
command line and in an application context, the context will take
precedence over the command line.
Thus, if the path to the desired working directory is different on the
backend nodes, then it must be specified as an absolute path that is
correct for the backend node.
.TP
\f[B]\f[CB]--wd <dir>\f[B]\f[R]
Synonym for \f[C]--wdir\f[R].
.TP
\f[B]\f[CB]-x <env>\f[B]\f[R]
Export the specified environment variables to the remote nodes before
executing the program.
Only one environment variable can be specified per \f[C]-x\f[R] option.
Existing environment variables can be specified or new variable names
specified with corresponding values.
If multiple \f[C]-x\f[R] options with the same variable name (regardless
of value) are provided then the last one listed on the command line will
take precedence, and the others will be ignored.
The exception to this is for PRTE_MCA_ prefixed environment variables
which will report an error in that scenario if any of the values differ.
For example: \f[C]$ prun -x DISPLAY -x OFILE=/tmp/out ...\f[R]
.PP
The parser for the \f[C]-x\f[R] option is not very sophisticated; it
does not even understand quoted values.
Users are advised to set variables in the environment, and then use
\f[C]-x\f[R] to export (not define) them.
.SS MCA Parameters
.PP
Setting MCA parameters take a few different forms depending the target
project for the parameter.
For example, MCA parameters targeting OpenPMIx will contain the string
\f[C]pmix\f[R] in their name, and MCA parameters targeting PRTE will
contain the string \f[C]prte\f[R] in their name.
See the \[lq]MCA\[rq] section, below, for finer details on the MCA.
.TP
\f[B]\f[CB]--gpmixmca <key> <value>\f[B]\f[R]
Pass global PMIx MCA parameters that are applicable to all application
contexts.
\f[C]<key>\f[R] is the parameter name; \f[C]<value>\f[R] is the
parameter value.
.TP
\f[B]\f[CB]--mca <key> <value>\f[B]\f[R]
Send arguments to various MCA modules.
See the \[lq]MCA\[rq] section, below.
.TP
\f[B]\f[CB]--pmixmca <key> <value>\f[B]\f[R]
Send arguments to various PMIx MCA modules.
See the \[lq]MCA\[rq] section, below.
.TP
\f[B]\f[CB]--prtemca <key> <value>\f[B]\f[R]
Send arguments to various PRTE MCA modules.
See the \[lq]MCA\[rq] section, below.
.TP
\f[B]\f[CB]--pmixam <arg0>\f[B]\f[R]
Aggregate PMIx MCA parameter set file list.
The \f[C]arg0\f[R] argument is a comma-separated list of tuning files.
Each file containing MCA parameter sets for this application context.
.SS Debugging Options
.TP
\f[B]\f[CB]--get-stack-traces\f[B]\f[R]
When paired with the \f[C]--timeout\f[R] option, \f[C]prun\f[R] will
obtain and print out stack traces from all launched processes that are
still alive when the timeout expires.
Note that obtaining stack traces can take a little time and produce a
lot of output, especially for large process-count jobs.
.TP
\f[B]\f[CB]--timeout <seconds>\f[B]\f[R]
The maximum number of seconds that \f[C]prun\f[R] will run.
After this many seconds, \f[C]prun\f[R] will abort the launched job and
exit with a non-zero exit status.
Using \f[C]--timeout\f[R] can be also useful when combined with the
\f[C]--get-stack-traces\f[R] option.
.SS Other Options
.PP
There are also other options:
.TP
\f[B]\f[CB]--allow-run-as-root\f[B]\f[R]
Allow \f[C]prun\f[R] to run when executed by the root user
(\f[C]prun\f[R] defaults to aborting when launched as the root user).
.TP
\f[B]\f[CB]--app <appfile>\f[B]\f[R]
Provide an \f[C]appfile\f[R], ignoring all other command line options.
.TP
\f[B]\f[CB]--continuous\f[B]\f[R]
Job is to run until explicitly terminated.
.TP
\f[B]\f[CB]--dvm-uri\f[B]\f[R]
Specify the URI of the DVM master, or the name of the file (specified as
file:filename) that contains that info.
.TP
\f[B]\f[CB]--enable-recovery\f[B]\f[R]
Enable recovery from process failure [Default = disabled].
.TP
\f[B]\f[CB]--disable-recovery\f[B]\f[R]
Disable recovery (resets all recovery options to off).
.TP
\f[B]\f[CB]--map-by :DONOTLAUNCH\f[B]\f[R]
Perform all necessary operations to prepare to launch the application,
but do not actually launch it.
.TP
\f[B]\f[CB]--index-argv-by-rank\f[B]\f[R]
Uniquely index \f[C]argv[0]\f[R] for each process using its rank.
.TP
\f[B]\f[CB]--max-restarts <num>\f[B]\f[R]
Max number of times to restart a failed process.
.TP
\f[B]\f[CB]--pid\f[B]\f[R]
PID of the daemon to which we should connect.
.TP
\f[B]\f[CB]--report-child-jobs-separately\f[B]\f[R]
Return the exit status of the primary job only.
.TP
\f[B]\f[CB]--show-progress\f[B]\f[R]
Output a brief periodic report on launch progress.
.TP
\f[B]\f[CB]--terminate\f[B]\f[R]
Terminate the DVM.
.PP
The following options are useful for developers; they are not generally
useful to most users:
.TP
\f[B]\f[CB]--map-by :DISPLAYALLOC\f[B]\f[R]
Display a detailed list of the allocation being used by this job.
.TP
\f[B]\f[CB]--map-by :DISPLAYDEVEL\f[B]\f[R]
Display a more detailed table showing the mapped location of each
process prior to launch.
.TP
\f[B]\f[CB]--map-by :DISPLAYTOPO\f[B]\f[R]
Display the topology as part of the process map just before launch.
.TP
\f[B]\f[CB]--report-state-on-timeout\f[B]\f[R]
When paired with the \f[C]--timeout\f[R] command line option, report the
run-time subsystem state of each process when the timeout expires.
.SH DESCRIPTION
.PP
One invocation of \f[C]prun\f[R] starts an application running under the
PRTE DVM.
If the application is single process multiple data (SPMD), the
application can be specified on the \f[C]prun\f[R] command line.
.PP
If the application is multiple instruction multiple data (MIMD),
comprising of multiple programs, the set of programs and argument can be
specified in one of two ways: Extended Command Line Arguments, and
Application Context.
.PP
An application context describes the MIMD program set including all
arguments in a separate file.
This file essentially contains multiple \f[C]prun\f[R] command lines,
less the command name itself.
The ability to specify different options for different instantiations of
a program is another reason to use an application context.
.PP
Extended command line arguments allow for the description of the
application layout on the command line using colons (\f[C]:\f[R]) to
separate the specification of programs and arguments.
Some options are globally set across all specified programs
(e.g.\ \f[C]--hostfile\f[R]), while others are specific to a single
program (e.g.\ \f[C]--np\f[R]).
.SS Specifying Host Nodes
.PP
Host nodes can be identified on the \f[C]prun\f[R] command line with the
\f[C]--host\f[R] option or in a hostfile.
See prte-map(1) for more details.
.SS Application Context or Executable Program?
.PP
To distinguish the two different forms, \f[C]prun\f[R] looks on the
command line for \f[C]--app\f[R] option.
If it is specified, then the file named on the command line is assumed
to be an application context.
If it is not specified, then the file is assumed to be an executable
program.
.SS Locating Files
.PP
If no relative or absolute path is specified for a file, \f[C]prun\f[R]
will first look for files by searching the directories specified by the
\f[C]--path\f[R] option.
If there is no \f[C]--path\f[R] option set or if the file is not found
at the \f[C]--path\f[R] location, then \f[C]prun\f[R] will search the
user\[cq]s PATH environment variable as defined on the source node(s).
.PP
If a relative directory is specified, it must be relative to the initial
working directory determined by the specific starter used.
For example when using the rsh or ssh starters, the initial directory is
\f[C]$HOME\f[R] by default.
Other starters may set the initial directory to the current working
directory from the invocation of \f[C]prun\f[R].
.SS Current Working Directory
.PP
The \f[C]--wdir\f[R] prun option (and its synonym, \f[C]--wd\f[R])
allows the user to change to an arbitrary directory before the program
is invoked.
It can also be used in application context files to specify working
directories on specific nodes and/or for specific applications.
.PP
If the \f[C]--wdir\f[R] option appears both in a context file and on the
command line, the context file directory will override the command line
value.
.PP
If the \f[C]--wdir\f[R] option is specified, \f[C]prun\f[R] will attempt
to change to the specified directory on all of the remote nodes.
If this fails, \f[C]prun\f[R] will abort.
.PP
If the \f[C]--wdir\f[R] option is \f[B]not\f[R] specified,
\f[C]prun\f[R] will send the directory name where \f[C]prun\f[R] was
invoked to each of the remote nodes.
The remote nodes will try to change to that directory.
If they are unable (e.g., if the directory does not exist on that node),
then \f[C]prun\f[R] will use the default directory determined by the
starter.
.PP
All directory changing occurs before the user\[cq]s program is invoked.
.SS Standard I/O
.PP
The PRTE DVM directs UNIX standard input to \f[C]/dev/null\f[R] on all
processes except the rank 0 process.
The rank 0 process inherits standard input from \f[C]prun\f[R].
\f[B]Note:\f[R] The node that invoked \f[C]prun\f[R] need not be the
same as the node where the rank 0 process resides.
PRTE DVM handles the redirection of \f[C]prun\f[R]\[cq]s standard input
to the rank 0 process.
.PP
The PRTE DVM directs UNIX standard output and error from remote nodes to
the node that invoked \f[C]prun\f[R] and prints it on the standard
output/error of \f[C]prun\f[R].
Local processes inherit the standard output/error of \f[C]prun\f[R] and
transfer to it directly.
.PP
Thus it is possible to redirect standard I/O for applications by using
the typical shell redirection procedure on \f[C]prun\f[R].
.IP
.nf
\f[C]
$ prun --np 2 my_app < my_input > my_output
\f[R]
.fi
.PP
Note that in this example \f[I]only\f[R] the rank 0 process will receive
the stream from \f[C]my_input\f[R] on stdin.
The stdin on all the other nodes will be tied to \f[C]/dev/null\f[R].
However, the stdout from all nodes will be collected into the
\f[C]my_output\f[R] file.
.SS Signal Propagation
.PP
When \f[C]prun\f[R] receives a \f[C]SIGTERM\f[R] and \f[C]SIGINT\f[R],
it will attempt to kill the entire job by sending all processes in the
job a \f[C]SIGTERM\f[R], waiting a small number of seconds, then sending
all processes in the job a \f[C]SIGKILL\f[R].
.PP
\f[C]SIGUSR1\f[R] and \f[C]SIGUSR2\f[R] signals received by
\f[C]prun\f[R] are propagated to all processes in the job.
.PP
A \f[C]SIGTSTOP\f[R] signal to \f[C]prun\f[R] will cause a
\f[C]SIGSTOP\f[R] signal to be sent to all of the programs started by
\f[C]prun\f[R] and likewise a \f[C]SIGCONT\f[R] signal to \f[C]prun\f[R]
will cause a \f[C]SIGCONT\f[R] sent.
.PP
Other signals are not currently propagated by \f[C]prun\f[R].
.SS Process Termination / Signal Handling
.PP
During the run of an application, if any process dies abnormally (either
exiting before invoking \f[C]PMIx_Finalize\f[R], or dying as the result
of a signal), \f[C]prun\f[R] will print out an error message and kill
the rest of the application.
.SS Process Environment
.PP
Processes in the application inherit their environment from the PRTE DVM
daemon upon the node on which they are running.
The environment is typically inherited from the user\[cq]s shell.
On remote nodes, the exact environment is determined by the boot MCA
module used.
The \f[C]rsh\f[R] launch module, for example, uses either
\f[C]rsh\f[R]/\f[C]ssh\f[R] to launch the PRTE DVM daemon on remote
nodes, and typically executes one or more of the user\[cq]s shell-setup
files before launching the daemon.
When running dynamically linked applications which require the
\f[C]LD_LIBRARY_PATH\f[R] environment variable to be set, care must be
taken to ensure that it is correctly set when booting PRTE DVM.
.PP
See the \[lq]Remote Execution\[rq] section for more details.
.SS Remote Execution
.PP
The PRTE DVM requires that the \f[C]PATH\f[R] environment variable be
set to find executables on remote nodes.
This is typically only necessary in \f[C]rsh\f[R]- or
\f[C]ssh\f[R]-based environments.
Batch and scheduled environments typically copy the current environment
to the execution of remote jobs, so if the current environment has
\f[C]PATH\f[R] and/or \f[C]LD_LIBRARY_PATH\f[R] set properly, the remote
nodes will also have it set properly.
If the PRTE DVM was compiled with shared library support, it may also be
necessary to have the \f[C]LD_LIBRARY_PATH\f[R] environment variable set
on remote nodes as well (especially to find the shared libraries
required to run user applications).
.PP
However, it is not always desirable or possible to edit shell startup
files to set \f[C]PATH\f[R] and/or \f[C]LD_LIBRARY_PATH\f[R].
The \f[C]--prefix\f[R] option is provided for some simple configurations
where this is not possible.
.PP
The \f[C]--prefix\f[R] option takes a single argument: the base
directory on the remote node where PRTE DVM is installed.
The PRTE DVM will use this directory to set the remote \f[C]PATH\f[R]
and \f[C]LD_LIBRARY_PATH\f[R] before executing any user applications.
This allows running jobs without having pre-configured the
\f[C]PATH\f[R] and \f[C]LD_LIBRARY_PATH\f[R] on the remote nodes.
.PP
The PRTE DVM adds the basename of the current node\[cq]s
\[lq]bindir\[rq] (the directory where the PRTE DVM\[cq]s executables are
installed) to the prefix and uses that to set the \f[C]PATH\f[R] on the
remote node.
Similarly, PRTE DVM adds the basename of the current node\[cq]s
\[lq]libdir\[rq] (the directory where the PRTE DVM\[cq]s libraries are
installed) to the prefix and uses that to set the
\f[C]LD_LIBRARY_PATH\f[R] on the remote node.
For example:
.TP
Local bindir:
/local/node/directory/bin
.TP
Local libdir:
/local/node/directory/lib64
.PP
If the following command line is used:
.IP
.nf
\f[C]
$ prun --prefix /remote/node/directory
\f[R]
.fi
.PP
The PRTE DVM will add \[lq]/remote/node/directory/bin\[rq] to the
\f[C]PATH\f[R] and \[lq]/remote/node/directory/lib64\[rq] to the
\f[C]LD_LIBRARY_PATH\f[R] on the remote node before attempting to
execute anything.
.PP
The \f[C]--prefix\f[R] option is not sufficient if the installation
paths on the remote node are different than the local node (e.g., if
\[lq]/lib\[rq] is used on the local node, but \[lq]/lib64\[rq] is used
on the remote node), or if the installation paths are something other
than a subdirectory under a common prefix.
.PP
Note that executing \f[C]prun\f[R] via an absolute pathname is
equivalent to specifying \f[C]--prefix\f[R] without the last
subdirectory in the absolute pathname to \f[C]prun\f[R].
.PP
For example:
.IP
.nf
\f[C]
$ /usr/local/bin/prun ...
\f[R]
.fi
.PP
is equivalent to
.IP
.nf
\f[C]
$ prun --prefix /usr/local ...
\f[R]
.fi
.SS Exported Environment Variables
.PP
All environment variables that are named in the form
\f[C]PMIX_\[rs]*\f[R] will automatically be exported to new processes on
the local and remote nodes.
Environmental parameters can also be set/forwarded to the new processes
using the MCA parameter \f[C]mca_base_env_list\f[R].
While the syntax of the \f[C]-x\f[R] option and MCA param allows the
definition of new variables, note that the parser for these options are
currently not very sophisticated - it does not even understand quoted
values.
Users are advised to set variables in the environment and use the option
to export them; not to define them.
.SS Setting MCA Parameters
.PP
The \f[C]--mca\f[R] / \f[C]--pmixmca\f[R] / \f[C]--prtemca\f[R] switches
(referenced here as \[lq]\f[C]--mca\f[R] switches\[rq] for brevity)
allow the passing of parameters to various MCA (Modular Component
Architecture) modules.
MCA modules have direct impact on programs because they allow tunable
parameters to be set at run time.
.PP
The \f[C]-mca\f[R] switch takes two arguments: \f[C]<key>\f[R] and
\f[C]<value>\f[R].
The \f[C]<key>\f[R] argument generally specifies which MCA module will
receive the value.
For example, the \f[C]<key>\f[R] \[lq]rmaps\[rq] is used to select which
RMAPS to be used for mapping processes to nodes.
The \f[C]<value>\f[R] argument is the value that is passed.
For example:
.TP
\f[B]\f[CB]prun -prtemca rmaps seq -np 1 foo\f[B]\f[R]
Tells PRTE to use the \[lq]seq\[rq] RMAPS component, and to run a single
copy of \[lq]a.out\[rq] on an allocated node.
.PP
The \f[C]-mca\f[R] switch can be used multiple times to specify
different \f[C]<key>\f[R] and/or \f[C]<value>\f[R] arguments.
If the same \f[C]<key>\f[R] is specified more than once, the
\f[C]<value>\f[R]s are concatenated with a comma (\[lq],\[rq])
separating them.
.PP
Note that the \f[C]-mca\f[R] switch is simply a shortcut for setting
environment variables.
The same effect may be accomplished by setting corresponding environment
variables before running \f[C]prun\f[R].
The form of the environment variables depends on the type of the
\f[C]--mca\f[R] switch.
.TP
\f[B]\f[CB]--mca\f[B]\f[R]
\f[C]PRTE_MCA_<key>=<value>\f[R]
.TP
\f[B]\f[CB]--pmixmca\f[B]\f[R]
\f[C]PMIX_MCA_<key>=<value>\f[R]
.TP
\f[B]\f[CB]--prtemca\f[B]\f[R]
\[ga]PRTE_MCA_=\[ga]\[ga]
.PP
Thus, the \f[C]-mca\f[R] switch overrides any previously set environment
variables.
The \f[C]-mca\f[R] settings similarly override MCA parameters set in the
\f[C]$PRTE_PREFIX/etc/prte-mca-params.conf\f[R] or
\f[C]$HOME/.prte/mca-params.conf\f[R] file.
.PP
Unknown \f[C]<key>\f[R] arguments are still set as environment variable
\[en] they are not checked (by \f[C]prun\f[R]) for correctness.
Illegal or incorrect \f[C]<value>\f[R] arguments may or may not be
reported \[en] it depends on the specific MCA module.
.PP
To find the available component types under the MCA architecture, or to
find the available parameters for a specific component, use the
\f[C]pinfo\f[R] command.
See the \f[I]pinfo(1)\f[R] man page for detailed information on the
command.
.SS Running as root
.PP
The PRTE team strongly advises against executing \f[C]prun\f[R] as the
root user.
Applications should be run as regular (non-root) users.
.PP
Reflecting this advice, \f[C]prun\f[R] will refuse to run as root by
default.
To override this default, you can add the \f[C]--allow-run-as-root\f[R]
option to the \f[C]prun\f[R] command line.
.SH RETURN VALUE
.PP
There is no standard definition for what \f[C]prun\f[R] should return as
an exit status.
After considerable discussion, we settled on the following method for
assigning the \f[C]prun\f[R] exit status (note: in the following
description, the \[lq]primary\[rq] job is the initial application
started by \f[C]prun\f[R] - all jobs that are spawned by that job are
designated \[lq]secondary\[rq] jobs):
.IP \[bu] 2
if all processes in the primary job normally terminate with exit status
0, we return 0
.IP \[bu] 2
if one or more processes in the primary job normally terminate with
non-zero exit status, we return the exit status of the process with the
lowest rank to have a non-zero status
.IP \[bu] 2
if all processes in the primary job normally terminate with exit status
0, and one or more processes in a secondary job normally terminate with
non-zero exit status, we (a) return the exit status of the process with
the lowest rank in the lowest jobid to have a non-zero status, and (b)
output a message summarizing the exit status of the primary and all
secondary jobs.
.IP \[bu] 2
if the cmd line option \f[C]--report-child-jobs-separately\f[R] is set,
we will return -only- the exit status of the primary job.
Any non-zero exit status in secondary jobs will be reported solely in a
summary print statement.
.PP
By default, the job will abort when any process terminates with non-zero
status.
The MCA parameter \f[C]prte_abort_on_non_zero_status\f[R] can be set to
\f[C]false\f[R] (or \f[C]0\f[R]) to cause the PRTE DVM to not abort a
job if one or more processes return a non-zero status.
In that situation the PRTE DVM records and notes that processes exited
with non-zero termination status to report the approprate exit status of
\f[C]prun\f[R] (per bullet points above).
.PP
If the \f[C]--timeout\f[R] command line option is used and the timeout
expires before the job completes (thereby forcing \f[C]prun\f[R] to kill
the job) \f[C]prun\f[R] will return an exit status equivalent to the
value of \f[C]ETIMEDOUT\f[R] (which is typically 110 on Linux and OS X
systems).
